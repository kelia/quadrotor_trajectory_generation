import time

import casadi as cs
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import ExpSineSquared

from utils.q_funcs import q_dot_q, quaternion_inverse
from utils.visualization import debug_plot, draw_poly


class Quad():
    def __init__(self, mass, max_thrust_per_motor):
        '''

        :param mass: mass of the quadrotor in [kg]
        :param max_thrust_per_motor: maximum thrust in [N] per motor
        '''
        self.mass = mass
        self.max_thrust_per_motor = max_thrust_per_motor

        self.J = np.array([.03, .03, .06])  # [0.001, 0.001, 0.002])
        arm_length = 0.2
        h = np.cos(np.pi / 4) * arm_length
        self.x_f = np.array([h, -h, -h, h])
        self.y_f = np.array([-h, -h, h, h])

        # For z thrust torque calculation
        self.c = 0.013  # m   (z torque generated by each motor)
        self.z_l_tau = np.array([-self.c, self.c, -self.c, self.c])


def check_trajectory(trajectory, inputs, tvec, plot=False):
    """
    @param trajectory:
    @param inputs:
    @param tvec:
    @param plot:
    @return:
    """

    print("Checking trajectory integrity...")

    dt = np.expand_dims(np.gradient(tvec, axis=0), axis=1)
    numeric_derivative = np.gradient(trajectory, axis=0) / dt

    errors = np.zeros((dt.shape[0], 3))

    num_bodyrates = []

    for i in range(dt.shape[0]):
        # 1) check if velocity is consistent with position
        numeric_velocity = numeric_derivative[i, 0:3]
        analytic_velocity = trajectory[i, 7:10]
        errors[i, 0] = np.linalg.norm(numeric_velocity - analytic_velocity)
        if not np.allclose(analytic_velocity, numeric_velocity, atol=0.05, rtol=0.05):
            print("inconsistent linear velocity at i = %d" % i)
            print(numeric_velocity)
            print(analytic_velocity)
            return False

        # 2) check if attitude is consistent with acceleration
        gravity = 9.81
        numeric_thrust = numeric_derivative[i, 7:10] + np.array([0.0, 0.0, gravity])
        numeric_thrust = numeric_thrust / np.linalg.norm(numeric_thrust)
        analytic_attitude = trajectory[i, 3:7]
        if np.abs(np.linalg.norm(analytic_attitude) - 1.0) > 1e-6:
            print("quaternion does not have unit norm at i = %d" % i)
            print(analytic_attitude)
            print(np.linalg.norm(analytic_attitude))
            return False

        e_z = np.array([0.0, 0.0, 1.0])
        q_w = 1.0 + np.dot(e_z, numeric_thrust)
        q_xyz = np.cross(e_z, numeric_thrust)
        numeric_attitude = 0.5 * np.array([q_w] + q_xyz.tolist())
        numeric_attitude = numeric_attitude / np.linalg.norm(numeric_attitude)
        # the two attitudes can only differ in yaw --> check x,y component
        q_diff = q_dot_q(quaternion_inverse(analytic_attitude), numeric_attitude)
        errors[i, 1] = np.linalg.norm(q_diff[1:3])
        if not np.allclose(q_diff[1:3], np.zeros(2, ), atol=0.05, rtol=0.05):
            print("Attitude and acceleration do not match at i = %d" % i)
            print(analytic_attitude)
            print(numeric_attitude)
            print(q_diff)
            return False

        # 3) check if bodyrates agree with attitude difference
        numeric_bodyrates = 2.0 * q_dot_q(quaternion_inverse(trajectory[i, 3:7]), numeric_derivative[i, 3:7])[1:]
        num_bodyrates.append(numeric_bodyrates)
        analytic_bodyrates = trajectory[i, 10:13]
        errors[i, 2] = np.linalg.norm(numeric_bodyrates - analytic_bodyrates)
        if not np.allclose(numeric_bodyrates, analytic_bodyrates, atol=0.05, rtol=0.05):
            print("inconsistent angular velocity at i = %d" % i)
            print(numeric_bodyrates)
            print(analytic_bodyrates)
            return False

    print("Trajectory check successful")
    print("Maximum linear velocity error: %.5f" % np.max(errors[:, 0]))
    print("Maximum attitude error: %.5f" % np.max(errors[:, 1]))
    print("Maximum angular velocity error: %.5f" % np.max(errors[:, 2]))

    if plot:
        num_bodyrates = np.stack(num_bodyrates)
        plt.figure()
        for i in range(3):
            plt.subplot(3, 2, i * 2 + 1)
            plt.plot(numeric_derivative[:, i], label='numeric')
            plt.plot(trajectory[:, 7 + i], label='analytic')
            plt.ylabel('m/s')
            if i == 0:
                plt.title("Velocity check")
            plt.legend()

        for i in range(3):
            plt.subplot(3, 2, i * 2 + 2)
            plt.plot(num_bodyrates[:, i], label='numeric')
            plt.plot(trajectory[:, 10 + i], label='analytic')
            plt.ylabel('rad/s')
            if i == 0:
                plt.title("Body rate check")
            plt.legend()
        plt.suptitle('Integrity check of reference trajectory')
        plt.show()

    return True


def compute_full_traj(t_np, pos_np, vel_np, alin_np):
    len_traj = t_np.shape[0]
    dt = np.mean(np.diff(t_np))
    print(dt)

    # Add gravity to accelerations
    gravity = 9.81
    thrust_np = alin_np + np.tile(np.array([[0, 0, 1]]), (len_traj, 1)) * gravity
    # Compute body axes
    z_b = thrust_np / np.sqrt(np.sum(thrust_np ** 2, 1))[:, np.newaxis]
    # new way to compute attitude:
    # https://math.stackexchange.com/questions/2251214/calculate-quaternions-from-two-directional-vectors
    e_z = np.array([[0.0, 0.0, 1.0]])
    q_w = 1.0 + np.sum(e_z * z_b, axis=1)
    q_xyz = np.cross(e_z, z_b)
    att_np = 0.5 * np.concatenate([np.expand_dims(q_w, axis=1), q_xyz], axis=1)
    att_np = att_np / np.sqrt(np.sum(att_np ** 2, 1))[:, np.newaxis]

    rate_np = np.zeros_like(pos_np)
    f_t = np.zeros((len_traj, 1))
    # for i in range(len_traj):
    #     f_t[i, 0] = quad.mass * z_b[i].dot(thrust[i, :].T)

    # Use numerical differentiation of quaternions
    q_dot = np.gradient(att_np, axis=0) / dt
    w_int = np.zeros((len_traj, 3))
    for i in range(len_traj):
        w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]
        print(thrust_np[i])
        f_t[i, 0] = quad.mass * thrust_np[i, 2]
    rate_np[:, 0] = w_int[:, 0]
    rate_np[:, 1] = w_int[:, 1]
    rate_np[:, 2] = w_int[:, 2]

    go_crazy_about_yaw = True
    if go_crazy_about_yaw:
        print("Maximum yawrate before adaption: %.3f" % np.max(np.abs(rate_np[:, 2])))
        q_new = att_np
        yaw_corr_acc = 0.0
        for i in range(1, len_traj):
            yaw_corr = -rate_np[i, 2] * dt
            yaw_corr_acc += yaw_corr
            q_corr = np.array([np.cos(yaw_corr_acc / 2.0), 0.0, 0.0, np.sin(yaw_corr_acc / 2.0)])
            q_new[i, :] = q_dot_q(att_np[i, :], q_corr)
            w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]

        q_new_dot = np.gradient(q_new, axis=0) / dt
        for i in range(1, len_traj):
            w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(q_new[i, :]), q_new_dot[i])[1:]

        att_np = q_new
        rate_np[:, 0] = w_int[:, 0]
        rate_np[:, 1] = w_int[:, 1]
        rate_np[:, 2] = w_int[:, 2]
        print("Maximum yawrate after adaption: %.3f" % np.max(np.abs(rate_np[:, 2])))

    arot_np = np.gradient(rate_np, axis=0)
    trajectory = np.concatenate([pos_np, att_np, vel_np, rate_np, alin_np, arot_np], axis=1)
    motor_inputs = np.zeros((pos_np.shape[0], 4))

    print(trajectory.shape)
    print(motor_inputs.shape)
    print(t_np.shape)

    return trajectory, motor_inputs, t_np


def compute_random_trajectory(quad, duration=30.0, dt=0.001):
    debug = False
    seed = None
    if seed is None:
        seed = np.random.randint(0, 9999)

    # kernel to map functions that repeat exactly
    kernel_z = ExpSineSquared(length_scale=1.5, periodicity=30)
    kernel_y = ExpSineSquared(length_scale=4.5, periodicity=30) + ExpSineSquared(length_scale=4.0, periodicity=15)
    kernel_x = ExpSineSquared(length_scale=4.5, periodicity=30) + ExpSineSquared(length_scale=4.5, periodicity=60)

    gp_x = GaussianProcessRegressor(kernel=kernel_x)
    gp_y = GaussianProcessRegressor(kernel=kernel_y)
    gp_z = GaussianProcessRegressor(kernel=kernel_z)

    # High resolution sampling for track boundaries
    inputs_x = np.linspace(0, 60, 100)
    inputs_y = np.linspace(0, 30, 100)
    inputs_z = np.linspace(0, 60, 100)

    x_sample_hr = gp_x.sample_y(inputs_x[:, np.newaxis], 1, random_state=seed)
    y_sample_hr = gp_y.sample_y(inputs_y[:, np.newaxis], 1, random_state=seed)
    z_sample_hr = gp_z.sample_y(inputs_z[:, np.newaxis], 1, random_state=seed)

    if debug:
        plt.plot(x_sample_hr, label="x")
        plt.plot(y_sample_hr, label="y")
        plt.plot(z_sample_hr, label="z")
        plt.legend()
        plt.show()


    pos_np = np.concatenate([x_sample_hr, y_sample_hr, z_sample_hr], axis=1)
    vel_np = np.zeros_like(pos_np)
    acc_np = np.zeros_like(pos_np)
    t_np = np.zeros(pos_np.shape[0])

    trajectory, motor_inputs, t_vec = compute_full_traj(t_np, pos_np, vel_np, acc_np)

    return trajectory, motor_inputs, t_vec


def compute_geometric_trajectory(quad, duration=30.0, dt=0.001):
    # Use a breakpoint in the code line below to debug your script.
    print("Computing trajectory!")

    # define position trajectory symbolically
    t = cs.MX.sym("t")
    # t_speed is a function starting at zero and ending at zero that modulates time
    # casadi cannot do symbolic integration --> write down the integrand by hand of 2.0*sin^2(t)
    t_adj = 2.0 * (t / 2.0 - cs.sin(2.0 / duration * cs.pi * t) / (4.0 * cs.pi / duration))

    # sphere trajectory rotating around x-axis
    radius = 5.0
    freq_slow = 0.1
    freq_fast = cs.sqrt(3.0)
    pos_x = 3.5 + radius * cs.cos(freq_fast * t_adj)
    pos_y = 2 + radius * (cs.sin(freq_fast * t_adj) * cs.cos(freq_slow * t_adj))
    pos_z = 3.5 + radius * (cs.sin(freq_fast * t_adj) * cs.sin(freq_slow * t_adj))

    # TODO: define yaw trajectory
    pos = cs.vertcat(pos_x, pos_y, pos_z)
    vel = cs.jacobian(pos, t)
    acc = cs.jacobian(vel, t)
    jerk = cs.jacobian(acc, t)
    snap = cs.jacobian(jerk, t)

    t_vec, dt = np.linspace(0.0, 30.0, int(duration / dt), endpoint=False, retstep=True)

    f_t_adj = cs.Function('t_adj', [t], [t_adj])
    f_pos = cs.Function('f_pos', [t], [pos])
    f_vel = cs.Function('f_vel', [t], [vel])
    f_acc = cs.Function('f_acc', [t], [acc])
    f_jerk = cs.Function('f_jerk', [t], [jerk])
    f_snap = cs.Function('f_snap', [t], [snap])

    # evaluation seems to only work for scalar inputs --> iterate over time vector
    pos_list = []
    vel_list = []
    alin_list = []
    att_list = []
    rate_list = []
    thrust_list = []
    t_adj_list = []
    for t_curr in t_vec:
        t_adj_list.append(f_t_adj(t_curr).full().squeeze())
        pos_list.append(f_pos(t_curr).full().squeeze())
        vel_list.append(f_vel(t_curr).full().squeeze())
        # compute attitude from acceleration
        gravity = np.array([0.0, 0.0, 9.81])
        curr_acc = f_acc(t_curr).full().squeeze()
        alin_list.append(curr_acc)
        thrust = curr_acc + gravity
        thrust_list.append(np.linalg.norm(thrust))

        z_b = thrust / np.linalg.norm(thrust)  # np.sqrt(np.sum(thrust ** 2, 1)) #[:, np.newaxis]
        e_z = np.array([0.0, 0.0, 1.0])
        # https://math.stackexchange.com/questions/2251214/calculate-quaternions-from-two-directional-vectors
        q_w = 1.0 + np.dot(e_z, z_b)
        q_xyz = np.cross(e_z, z_b)
        q = 0.5 * np.array([q_w, q_xyz[0], q_xyz[1], q_xyz[2]])
        q = q / np.linalg.norm(q)
        att_list.append(q)

    t_adj_np = np.array(t_adj_list)
    pos_np = np.array(pos_list)
    vel_np = np.array(vel_list)
    alin_np = np.array(alin_list)
    att_np = np.array(att_list)
    rate_np = np.zeros_like(pos_np)
    thrust_np = np.array(thrust_list)

    len_traj = att_np.shape[0]
    # there are possible quaternion flips, let's remove them first...
    for i in range(1, len_traj):
        # compute difference w.r.t. previous quaternion
        quat_diff_no_flip = np.linalg.norm(att_np[i, :] - att_np[i - 1, :])
        quat_diff_flip = np.linalg.norm(att_np[i, :] + att_np[i - 1, :])
        if quat_diff_flip < quat_diff_no_flip:
            print("detected flip ")

    # compute the bodyrates by numeric differentiation of the attitude
    q_dot = np.gradient(att_np, axis=0) / dt
    w_int = np.zeros((len_traj, 3))
    f_t = np.zeros((len_traj, 1))
    for i in range(len_traj):
        w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]
        f_t[i, 0] = quad.mass * thrust_np[i]
    rate_np[:, 0] = w_int[:, 0]
    rate_np[:, 1] = w_int[:, 1]
    rate_np[:, 2] = w_int[:, 2]

    go_crazy_about_yaw = True
    n_iter_yaw_fix = 20
    if go_crazy_about_yaw:
        for iter_yaw_fix in range(n_iter_yaw_fix):
            print("Maximum yawrate before adaption %d / %d: %.6f" % (
                iter_yaw_fix, n_iter_yaw_fix, np.max(np.abs(rate_np[:, 2]))))
            q_new = att_np
            yaw_corr_acc = 0.0
            for i in range(1, len_traj):
                yaw_corr = -rate_np[i, 2] * dt
                yaw_corr_acc += yaw_corr
                q_corr = np.array([np.cos(yaw_corr_acc / 2.0), 0.0, 0.0, np.sin(yaw_corr_acc / 2.0)])
                q_new[i, :] = q_dot_q(att_np[i, :], q_corr)
                w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]

            q_new_dot = np.gradient(q_new, axis=0) / dt
            for i in range(1, len_traj):
                w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(q_new[i, :]), q_new_dot[i])[1:]

            att_np = q_new
            rate_np[:, 0] = w_int[:, 0]
            rate_np[:, 1] = w_int[:, 1]
            rate_np[:, 2] = w_int[:, 2]
            print("Maximum yawrate after adaption: %.3f" % np.max(np.abs(rate_np[:, 2])))

    arot_np = np.gradient(rate_np, axis=0)
    trajectory = np.concatenate([pos_np, att_np, vel_np, rate_np, alin_np, arot_np], axis=1)
    motor_inputs = np.zeros((pos_np.shape[0], 4))

    # Compute inputs
    rate_dot = np.gradient(rate_np, axis=0) / dt
    rate_x_Jrate = np.array([(quad.J[2] - quad.J[1]) * rate_np[:, 2] * rate_np[:, 1],
                             (quad.J[0] - quad.J[2]) * rate_np[:, 0] * rate_np[:, 2],
                             (quad.J[1] - quad.J[0]) * rate_np[:, 1] * rate_np[:, 0]]).T

    tau = rate_dot * quad.J[np.newaxis, :] + rate_x_Jrate
    b = np.concatenate((tau, f_t), axis=-1)
    a_mat = np.concatenate((quad.y_f[np.newaxis, :], -quad.x_f[np.newaxis, :],
                            quad.z_l_tau[np.newaxis, :], np.ones_like(quad.z_l_tau)[np.newaxis, :]), 0)

    for i in range(len_traj):
        motor_inputs[i, :] = np.linalg.solve(a_mat, b[i, :])

    fig, ax = plt.subplots()
    ax.plot(t_vec, t_adj_np)
    plt.show()

    return trajectory, motor_inputs, t_vec


if __name__ == '__main__':

    start_time = time.time()
    quad = Quad(0.772, 10.0)
    debug = False
    output_fn = "/home/elia/Desktop/trajectory.csv"

    # trajectory, motor_inputs, t_vec = compute_geometric_trajectory(quad)
    trajectory, motor_inputs, t_vec = compute_random_trajectory(quad)

    print(trajectory.shape)
    print(motor_inputs.shape)
    print(t_vec.shape)

    if check_trajectory(trajectory, motor_inputs, t_vec, False):
        if debug:
            debug_plot(trajectory, motor_inputs, t_vec)
        draw_poly(trajectory[:, :13], motor_inputs, t_vec)

        # save trajectory to csv
        df_traj = pd.DataFrame()
        df_traj['t'] = t_vec
        df_traj['p_x'] = trajectory[:, 0]
        df_traj['p_y'] = trajectory[:, 1]
        df_traj['p_z'] = trajectory[:, 2]

        df_traj['q_w'] = trajectory[:, 3]
        df_traj['q_x'] = trajectory[:, 4]
        df_traj['q_y'] = trajectory[:, 5]
        df_traj['q_z'] = trajectory[:, 6]

        df_traj['v_x'] = trajectory[:, 7]
        df_traj['v_y'] = trajectory[:, 8]
        df_traj['v_z'] = trajectory[:, 9]

        df_traj['w_x'] = trajectory[:, 10]
        df_traj['w_y'] = trajectory[:, 11]
        df_traj['w_z'] = trajectory[:, 12]

        df_traj['a_lin_x'] = trajectory[:, 13]
        df_traj['a_lin_y'] = trajectory[:, 14]
        df_traj['a_lin_z'] = trajectory[:, 15]

        df_traj['a_rot_x'] = trajectory[:, 16]
        df_traj['a_rot_y'] = trajectory[:, 17]
        df_traj['a_rot_z'] = trajectory[:, 18]

        df_traj['u_1'] = motor_inputs[:, 0] / quad.max_thrust_per_motor
        df_traj['u_2'] = motor_inputs[:, 1] / quad.max_thrust_per_motor
        df_traj['u_3'] = motor_inputs[:, 2] / quad.max_thrust_per_motor
        df_traj['u_4'] = motor_inputs[:, 3] / quad.max_thrust_per_motor

        df_traj.to_csv(output_fn, index=False)
    print("Trajectory generation took [%.3f] seconds." % (time.time() - start_time))
