import time

import casadi as cs
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from utils.q_funcs import q_dot_q, quaternion_inverse
from utils.visualization import debug_plot, draw_poly


class Quad():
    def __init__(self, mass, max_thrust_per_motor):
        '''

        :param mass: mass of the quadrotor in [kg]
        :param max_thrust_per_motor: maximum thrust in [N] per motor
        '''
        self.mass = mass
        self.max_thrust_per_motor = max_thrust_per_motor

        self.J = np.array([.03, .03, .06])  # [0.001, 0.001, 0.002])
        arm_length = 0.2
        h = np.cos(np.pi / 4) * arm_length
        self.x_f = np.array([h, -h, -h, h])
        self.y_f = np.array([-h, -h, h, h])

        # For z thrust torque calculation
        self.c = 0.013  # m   (z torque generated by each motor)
        self.z_l_tau = np.array([-self.c, self.c, -self.c, self.c])


def check_trajectory(trajectory, inputs, tvec, plot=False):
    """
    @param trajectory:
    @param inputs:
    @param tvec:
    @param plot:
    @return:
    """

    print("Checking trajectory integrity...")

    dt = np.expand_dims(np.gradient(tvec, axis=0), axis=1)
    numeric_derivative = np.gradient(trajectory, axis=0) / dt

    errors = np.zeros((dt.shape[0], 3))

    num_bodyrates = []

    for i in range(dt.shape[0]):
        # 1) check if velocity is consistent with position
        numeric_velocity = numeric_derivative[i, 0:3]
        analytic_velocity = trajectory[i, 7:10]
        errors[i, 0] = np.linalg.norm(numeric_velocity - analytic_velocity)
        if not np.allclose(analytic_velocity, numeric_velocity, atol=0.05, rtol=0.05):
            print("inconsistent linear velocity at i = %d" % i)
            print(numeric_velocity)
            print(analytic_velocity)
            return False

        # 2) check if attitude is consistent with acceleration
        gravity = 9.81
        numeric_thrust = numeric_derivative[i, 7:10] + np.array([0.0, 0.0, gravity])
        numeric_thrust = numeric_thrust / np.linalg.norm(numeric_thrust)
        analytic_attitude = trajectory[i, 3:7]
        if np.abs(np.linalg.norm(analytic_attitude) - 1.0) > 1e-6:
            print("quaternion does not have unit norm at i = %d" % i)
            print(analytic_attitude)
            print(np.linalg.norm(analytic_attitude))
            return False

        e_z = np.array([0.0, 0.0, 1.0])
        q_w = 1.0 + np.dot(e_z, numeric_thrust)
        q_xyz = np.cross(e_z, numeric_thrust)
        numeric_attitude = 0.5 * np.array([q_w] + q_xyz.tolist())
        numeric_attitude = numeric_attitude / np.linalg.norm(numeric_attitude)
        # the two attitudes can only differ in yaw --> check x,y component
        q_diff = q_dot_q(quaternion_inverse(analytic_attitude), numeric_attitude)
        errors[i, 1] = np.linalg.norm(q_diff[1:3])
        if not np.allclose(q_diff[1:3], np.zeros(2, ), atol=0.05, rtol=0.05):
            print("Attitude and acceleration do not match at i = %d" % i)
            print(analytic_attitude)
            print(numeric_attitude)
            print(q_diff)
            return False

        # 3) check if bodyrates agree with attitude difference
        numeric_bodyrates = 2.0 * q_dot_q(quaternion_inverse(trajectory[i, 3:7]), numeric_derivative[i, 3:7])[1:]
        num_bodyrates.append(numeric_bodyrates)
        analytic_bodyrates = trajectory[i, 10:13]
        errors[i, 2] = np.linalg.norm(numeric_bodyrates - analytic_bodyrates)
        if not np.allclose(numeric_bodyrates, analytic_bodyrates, atol=0.05, rtol=0.05):
            print("inconsistent angular velocity at i = %d" % i)
            print(numeric_bodyrates)
            print(analytic_bodyrates)
            return False

    print("Trajectory check successful")
    print("Maximum linear velocity error: %.5f" % np.max(errors[:, 0]))
    print("Maximum attitude error: %.5f" % np.max(errors[:, 1]))
    print("Maximum angular velocity error: %.5f" % np.max(errors[:, 2]))

    if plot:
        num_bodyrates = np.stack(num_bodyrates)
        plt.figure()
        for i in range(3):
            plt.subplot(3, 2, i * 2 + 1)
            plt.plot(numeric_derivative[:, i], label='numeric')
            plt.plot(trajectory[:, 7 + i], label='analytic')
            plt.ylabel('m/s')
            if i == 0:
                plt.title("Velocity check")
            plt.legend()

        for i in range(3):
            plt.subplot(3, 2, i * 2 + 2)
            plt.plot(num_bodyrates[:, i], label='numeric')
            plt.plot(trajectory[:, 10 + i], label='analytic')
            plt.ylabel('rad/s')
            if i == 0:
                plt.title("Body rate check")
            plt.legend()
        plt.suptitle('Integrity check of reference trajectory')
        plt.show()

    return True


def compute_trajectory(quad, duration=30.0, dt=0.001):
    # Use a breakpoint in the code line below to debug your script.
    print("Computing trajectory!")

    # define position trajectory symbolically
    t = cs.MX.sym("t")
    # t_speed is a function starting at zero and ending at zero that modulates time
    t_speed = cs.sin(t / duration * cs.pi) * cs.sin(t / duration * cs.pi)
    # t_adj = cs.integrator(t_speed)
    # casadi cannot do symbolic integration --> write down the integrand by hand
    t_adj = 2.0 * (t / 2.0 - cs.sin(2.0 / duration * cs.pi * t) / (4.0 * cs.pi / duration))

    # sphere trajectory rotating around x-axis
    radius = 5.0
    freq_slow = 0.1
    freq_fast = cs.sqrt(3.0)
    pos_x = 3.5 + radius * cs.cos(freq_fast * t_adj)
    pos_y = 2 + radius * (cs.sin(freq_fast * t_adj) * cs.cos(freq_slow * t_adj))
    pos_z = 3.5 + radius * (cs.sin(freq_fast * t_adj) * cs.sin(freq_slow * t_adj))

    # TODO: define yaw trajectory
    pos = cs.vertcat(pos_x, pos_y, pos_z)
    vel = cs.jacobian(pos, t)
    acc = cs.jacobian(vel, t)
    jerk = cs.jacobian(acc, t)
    snap = cs.jacobian(jerk, t)

    t_vec, dt = np.linspace(0.0, 30.0, int(duration / dt), endpoint=False, retstep=True)

    f_t_adj = cs.Function('t_adj', [t], [t_adj])
    f_pos = cs.Function('f_pos', [t], [pos])
    f_vel = cs.Function('f_vel', [t], [vel])
    f_acc = cs.Function('f_acc', [t], [acc])
    f_jerk = cs.Function('f_jerk', [t], [jerk])
    f_snap = cs.Function('f_snap', [t], [snap])

    # evaluation seems to only work for scalar inputs --> iterate over time vector
    pos_list = []
    vel_list = []
    alin_list = []
    att_list = []
    rate_list = []
    thrust_list = []
    t_adj_list = []
    for t_curr in t_vec:
        t_adj_list.append(f_t_adj(t_curr).full().squeeze())
        pos_list.append(f_pos(t_curr).full().squeeze())
        vel_list.append(f_vel(t_curr).full().squeeze())
        # compute attitude from acceleration
        gravity = np.array([0.0, 0.0, 9.81])
        curr_acc = f_acc(t_curr).full().squeeze()
        alin_list.append(curr_acc)
        thrust = curr_acc + gravity
        thrust_list.append(np.linalg.norm(thrust))

        z_b = thrust / np.linalg.norm(thrust)  # np.sqrt(np.sum(thrust ** 2, 1)) #[:, np.newaxis]
        e_z = np.array([0.0, 0.0, 1.0])
        # https://math.stackexchange.com/questions/2251214/calculate-quaternions-from-two-directional-vectors
        q_w = 1.0 + np.dot(e_z, z_b)
        q_xyz = np.cross(e_z, z_b)
        q = 0.5 * np.array([q_w, q_xyz[0], q_xyz[1], q_xyz[2]])
        q = q / np.linalg.norm(q)
        att_list.append(q)

    t_adj_np = np.array(t_adj_list)
    pos_np = np.array(pos_list)
    vel_np = np.array(vel_list)
    alin_np = np.array(alin_list)
    att_np = np.array(att_list)
    rate_np = np.zeros_like(pos_np)
    thrust_np = np.array(thrust_list)

    len_traj = att_np.shape[0]
    # there are possible quaternion flips, let's remove them first...
    for i in range(1, len_traj):
        # compute difference w.r.t. previous quaternion
        quat_diff_no_flip = np.linalg.norm(att_np[i, :] - att_np[i - 1, :])
        quat_diff_flip = np.linalg.norm(att_np[i, :] + att_np[i - 1, :])
        if quat_diff_flip < quat_diff_no_flip:
            print("detected flip ")

    # compute the bodyrates by numeric differentiation of the attitude
    q_dot = np.gradient(att_np, axis=0) / dt
    w_int = np.zeros((len_traj, 3))
    f_t = np.zeros((len_traj, 1))
    for i in range(len_traj):
        w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]
        f_t[i, 0] = quad.mass * thrust_np[i]
    rate_np[:, 0] = w_int[:, 0]
    rate_np[:, 1] = w_int[:, 1]
    rate_np[:, 2] = w_int[:, 2]

    go_crazy_about_yaw = True
    n_iter_yaw_fix = 20
    if go_crazy_about_yaw:
        for iter_yaw_fix in range(n_iter_yaw_fix):
            print("Maximum yawrate before adaption %d / %d: %.6f" % (
                iter_yaw_fix, n_iter_yaw_fix, np.max(np.abs(rate_np[:, 2]))))
            q_new = att_np
            yaw_corr_acc = 0.0
            for i in range(1, len_traj):
                yaw_corr = -rate_np[i, 2] * dt
                yaw_corr_acc += yaw_corr
                q_corr = np.array([np.cos(yaw_corr_acc / 2.0), 0.0, 0.0, np.sin(yaw_corr_acc / 2.0)])
                q_new[i, :] = q_dot_q(att_np[i, :], q_corr)
                w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(att_np[i, :]), q_dot[i])[1:]

            q_new_dot = np.gradient(q_new, axis=0) / dt
            for i in range(1, len_traj):
                w_int[i, :] = 2.0 * q_dot_q(quaternion_inverse(q_new[i, :]), q_new_dot[i])[1:]

            att_np = q_new
            rate_np[:, 0] = w_int[:, 0]
            rate_np[:, 1] = w_int[:, 1]
            rate_np[:, 2] = w_int[:, 2]
            print("Maximum yawrate after adaption: %.3f" % np.max(np.abs(rate_np[:, 2])))

    arot_np = np.gradient(rate_np, axis=0)
    trajectory = np.concatenate([pos_np, att_np, vel_np, rate_np, alin_np, arot_np], axis=1)
    motor_inputs = np.zeros((pos_np.shape[0], 4))

    # Compute inputs
    rate_dot = np.gradient(rate_np, axis=0) / dt
    rate_x_Jrate = np.array([(quad.J[2] - quad.J[1]) * rate_np[:, 2] * rate_np[:, 1],
                             (quad.J[0] - quad.J[2]) * rate_np[:, 0] * rate_np[:, 2],
                             (quad.J[1] - quad.J[0]) * rate_np[:, 1] * rate_np[:, 0]]).T

    tau = rate_dot * quad.J[np.newaxis, :] + rate_x_Jrate
    b = np.concatenate((tau, f_t), axis=-1)
    a_mat = np.concatenate((quad.y_f[np.newaxis, :], -quad.x_f[np.newaxis, :],
                            quad.z_l_tau[np.newaxis, :], np.ones_like(quad.z_l_tau)[np.newaxis, :]), 0)

    for i in range(len_traj):
        motor_inputs[i, :] = np.linalg.solve(a_mat, b[i, :])

    fig, ax = plt.subplots()
    ax.plot(t_vec, t_adj_np)
    plt.show()

    return trajectory, motor_inputs, t_vec


if __name__ == '__main__':

    start_time = time.time()
    quad = Quad(0.772, 10.0)
    debug = False
    output_fn = "/home/elia/Desktop/trajectory.csv"

    trajectory, motor_inputs, t_vec = compute_trajectory(quad)

    if check_trajectory(trajectory, motor_inputs, t_vec, False):
        if debug:
            debug_plot(trajectory, motor_inputs, t_vec)
        draw_poly(trajectory[:, :13], motor_inputs, t_vec)

        # save trajectory to csv
        df_traj = pd.DataFrame()
        df_traj['t'] = t_vec
        df_traj['p_x'] = trajectory[:, 0]
        df_traj['p_y'] = trajectory[:, 1]
        df_traj['p_z'] = trajectory[:, 2]

        df_traj['q_w'] = trajectory[:, 3]
        df_traj['q_x'] = trajectory[:, 4]
        df_traj['q_y'] = trajectory[:, 5]
        df_traj['q_z'] = trajectory[:, 6]

        df_traj['v_x'] = trajectory[:, 7]
        df_traj['v_y'] = trajectory[:, 8]
        df_traj['v_z'] = trajectory[:, 9]

        df_traj['w_x'] = trajectory[:, 10]
        df_traj['w_y'] = trajectory[:, 11]
        df_traj['w_z'] = trajectory[:, 12]

        df_traj['a_lin_x'] = trajectory[:, 13]
        df_traj['a_lin_y'] = trajectory[:, 14]
        df_traj['a_lin_z'] = trajectory[:, 15]

        df_traj['a_rot_x'] = trajectory[:, 16]
        df_traj['a_rot_y'] = trajectory[:, 17]
        df_traj['a_rot_z'] = trajectory[:, 18]

        df_traj['u_1'] = motor_inputs[:, 0] / quad.max_thrust_per_motor
        df_traj['u_2'] = motor_inputs[:, 1] / quad.max_thrust_per_motor
        df_traj['u_3'] = motor_inputs[:, 2] / quad.max_thrust_per_motor
        df_traj['u_4'] = motor_inputs[:, 3] / quad.max_thrust_per_motor

        df_traj.to_csv(output_fn, index=False)
    print("Trajectory generation took [%.3f] seconds." % (time.time() - start_time))
